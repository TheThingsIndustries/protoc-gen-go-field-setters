// Code generated by protoc-gen-go-field-setters. DO NOT EDIT.
// versions:
// - protoc-gen-go-field-setters v0.0.0-dev
// - protoc             v3.17.3
// source: messages.proto

package test

import (
	fmt "fmt"
	fieldsetterplugin "github.com/TheThingsIndustries/protoc-gen-go-field-setters/fieldsetterplugin"
)

// SetFields sets the given fields from src into x.
func (x *SubMessage) SetFields(src *SubMessage, paths ...string) error {
	switch {
	case x == nil && src == nil:
		return nil
	case x == nil:
		return fmt.Errorf("can not set fields into nil SubMessage")
	case src == nil:
		src = &SubMessage{}
	}
	fset := make(fieldsetterplugin.FieldSet)
	for _, field := range fieldsetterplugin.TopLevelPaths(paths) {
		if fset.Contains(field) {
			continue
		}
		switch field {
		default:
			return fieldsetterplugin.FieldErrorf(x, field, "unknown field")
		case "foo":
			x.Foo = src.Foo
		case "bar":
			x.Bar = src.Bar
		}
		fset.Add(field)
	}
	return nil
}

// SetFields sets the given fields from src into x.
func (x *MessageWithSubMessages) SetFields(src *MessageWithSubMessages, paths ...string) error {
	switch {
	case x == nil && src == nil:
		return nil
	case x == nil:
		return fmt.Errorf("can not set fields into nil MessageWithSubMessages")
	case src == nil:
		src = &MessageWithSubMessages{}
	}
	fset := make(fieldsetterplugin.FieldSet)
	for _, field := range fieldsetterplugin.TopLevelPaths(paths) {
		if fset.Contains(field) {
			continue
		}
		switch field {
		default:
			return fieldsetterplugin.FieldErrorf(x, field, "unknown field")
		case "a":
			x.A = src.A
		case "b":
			x.B = src.B
		}
		fset.Add(field)
	}
	for _, field := range fieldsetterplugin.SubPaths(paths) {
		topLevelField := fieldsetterplugin.TopLevelField(field)
		if fset.Contains(topLevelField) {
			continue
		}
		switch topLevelField {
		default:
			return fieldsetterplugin.FieldErrorf(x, field, "unknown field")
		case "a":
			if x.A == nil && src.A != nil {
				var v SubMessage
				x.A = &v
			}
			if err := x.A.SetFields(src.A, fieldsetterplugin.SubPathsOf(paths, topLevelField)...); err != nil {
				return fieldsetterplugin.WrapFieldError(x, field, err)
			}
		case "b":
			if x.B == nil && src.B != nil {
				var v SubMessage
				x.B = &v
			}
			if err := x.B.SetFields(src.B, fieldsetterplugin.SubPathsOf(paths, topLevelField)...); err != nil {
				return fieldsetterplugin.WrapFieldError(x, field, err)
			}
		}
		fset.Add(topLevelField)
	}
	return nil
}

// SetFields sets the given fields from src into x.
func (x *MessageWithOneofSubMessages) SetFields(src *MessageWithOneofSubMessages, paths ...string) error {
	switch {
	case x == nil && src == nil:
		return nil
	case x == nil:
		return fmt.Errorf("can not set fields into nil MessageWithOneofSubMessages")
	case src == nil:
		src = &MessageWithOneofSubMessages{}
	}
	fset := make(fieldsetterplugin.FieldSet)
	for _, field := range fieldsetterplugin.TopLevelPaths(paths) {
		if fset.Contains(field) {
			continue
		}
		switch field {
		default:
			return fieldsetterplugin.FieldErrorf(x, field, "unknown field")
		case "a":
			ov, ok := src.Sub.(*MessageWithOneofSubMessages_A)
			if !ok {
				return fieldsetterplugin.FieldErrorf(x, field, "invalid Sub of type %T in source struct", src.Sub)
			}
			x.Sub = ov
		case "b":
			ov, ok := src.Sub.(*MessageWithOneofSubMessages_B)
			if !ok {
				return fieldsetterplugin.FieldErrorf(x, field, "invalid Sub of type %T in source struct", src.Sub)
			}
			x.Sub = ov
		case "sub":
			x.Sub = src.Sub
		}
		fset.Add(field)
	}
	for _, field := range fieldsetterplugin.SubPaths(paths) {
		topLevelField := fieldsetterplugin.TopLevelField(field)
		if fset.Contains(topLevelField) {
			continue
		}
		switch topLevelField {
		default:
			return fieldsetterplugin.FieldErrorf(x, field, "unknown field")
		case "a":
			if x.Sub == nil && src.Sub != nil {
				ov := &MessageWithOneofSubMessages_A{A: &SubMessage{}}
				x.Sub = ov
			}
			xOV, ok := x.Sub.(*MessageWithOneofSubMessages_A)
			if !ok {
				return fieldsetterplugin.FieldErrorf(x, field, "invalid Sub of type %T in destination struct", x.Sub)
			}
			srcOV, ok := src.Sub.(*MessageWithOneofSubMessages_A)
			if !ok {
				return fieldsetterplugin.FieldErrorf(x, field, "invalid Sub of type %T in source struct", src.Sub)
			}
			if err := xOV.A.SetFields(srcOV.A, fieldsetterplugin.SubPathsOf(paths, topLevelField)...); err != nil {
				return fieldsetterplugin.WrapFieldError(x, field, err)
			}
		case "b":
			if x.Sub == nil && src.Sub != nil {
				ov := &MessageWithOneofSubMessages_B{B: &SubMessage{}}
				x.Sub = ov
			}
			xOV, ok := x.Sub.(*MessageWithOneofSubMessages_B)
			if !ok {
				return fieldsetterplugin.FieldErrorf(x, field, "invalid Sub of type %T in destination struct", x.Sub)
			}
			srcOV, ok := src.Sub.(*MessageWithOneofSubMessages_B)
			if !ok {
				return fieldsetterplugin.FieldErrorf(x, field, "invalid Sub of type %T in source struct", src.Sub)
			}
			if err := xOV.B.SetFields(srcOV.B, fieldsetterplugin.SubPathsOf(paths, topLevelField)...); err != nil {
				return fieldsetterplugin.WrapFieldError(x, field, err)
			}
		case "sub":
			if err := x.SetFields(src, fieldsetterplugin.SubPathsOf(paths, topLevelField)...); err != nil {
				return err
			}
		}
		fset.Add(topLevelField)
	}
	return nil
}
